<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pkg/logger_test.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/logger_test.go" />
              <option name="originalContent" value="package pkg&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;testing&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;log/slog&quot;&#10;&#10;&#9;&quot;go.opentelemetry.io/otel/metric&quot;&#10;&#9;&quot;go.opentelemetry.io/otel/trace&quot;&#10;)&#10;&#10;// fakeCounter registra le chiamate a Add per ispezione nei test&#10;type counterCall struct {&#10;&#9;ctx   context.Context&#10;&#9;value int64&#10;}&#10;&#10;type fakeCounter struct {&#10;&#9;name  string&#10;&#9;calls *[]counterCall&#10;}&#10;&#10;func (f *fakeCounter) Add(ctx context.Context, value int64, _ ...metric.AddOption) {&#10;&#9;*f.calls = append(*f.calls, counterCall{ctx: ctx, value: value})&#10;}&#10;&#10;// implementa le interfacce usate (Int64CounterLike e Int64UpDownCounterLike hanno lo stesso metodo Add)&#10;&#10;// fakeMeter crea strumenti fake che registrano le chiamate&#10;type fakeMeter struct {&#10;&#9;counters map[string]*[]counterCall&#10;}&#10;&#10;func newFakeMeter() *fakeMeter {&#10;&#9;return &amp;fakeMeter{counters: map[string]*[]counterCall{}}&#10;}&#10;&#10;func (m *fakeMeter) Int64Counter(name string, _ ...metric.InstrumentOption) (Int64CounterLike, error) {&#10;&#9;arr := make([]counterCall, 0)&#10;&#9;m.counters[name] = &amp;arr&#10;&#9;return &amp;fakeCounter{name: name, calls: m.counters[name]}, nil&#10;}&#10;&#10;func (m *fakeMeter) Int64UpDownCounter(name string, _ ...metric.InstrumentOption) (Int64UpDownCounterLike, error) {&#10;&#9;arr := make([]counterCall, 0)&#10;&#9;m.counters[name] = &amp;arr&#10;&#9;// riuso fakeCounter poiché Add ha la stessa forma&#10;&#9;return &amp;fakeCounter{name: name, calls: m.counters[name]}, nil&#10;}&#10;&#10;// fakeSlogHandler cattura i record inoltrati e permette di sincronizzare i test&#10;type fakeSlogHandler struct {&#10;&#9;mu      sync.Mutex&#10;&#9;records []slog.Record&#10;&#9;wg      *sync.WaitGroup&#10;}&#10;&#10;func newFakeSlogHandler() *fakeSlogHandler {&#10;&#9;return &amp;fakeSlogHandler{}&#10;}&#10;&#10;func (f *fakeSlogHandler) Handle(ctx context.Context, r slog.Record) error {&#10;&#9;f.mu.Lock()&#10;&#9;defer f.mu.Unlock()&#10;&#9;f.records = append(f.records, r)&#10;&#9;if f.wg != nil {&#10;&#9;&#9;f.wg.Done()&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func (f *fakeSlogHandler) Enabled(ctx context.Context, level slog.Level) bool { return true }&#10;func (f *fakeSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler           { return f }&#10;func (f *fakeSlogHandler) WithGroup(name string) slog.Handler                 { return f }&#10;&#10;// helper: aspetta fino a timeout che il fake handler abbia almeno n record&#10;func waitForRecords(t *testing.T, fh *fakeSlogHandler, n int, timeout time.Duration) {&#10;&#9;deadline := time.Now().Add(timeout)&#10;&#9;for time.Now().Before(deadline) {&#10;&#9;&#9;fh.mu.Lock()&#10;&#9;&#9;cnt := len(fh.records)&#10;&#9;&#9;fh.mu.Unlock()&#10;&#9;&#9;if cnt &gt;= n {&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;time.Sleep(5 * time.Millisecond)&#10;&#9;}&#10;&#9;t.Fatalf(&quot;timed out waiting for %d records, got %d&quot;, n, len(fh.records))&#10;}&#10;&#10;// Test 1: forwarding when no trace present&#10;func TestForwardingNoTrace(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;no-trace&quot;, 0)&#10;&#9;var ctx = context.Background()&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// aspetta che next riceva&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for next.Handle for no-trace record&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test 2: buffering + EndSpanSuccess (should cleanup without flush)&#10;func TestBufferingEndSpanSuccess(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;// costruisco un ctx con SpanContext valido contenente un traceID&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{1, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// sanity check sulla validità del contesto&#10;&#9;if !sc.IsValid() {&#10;&#9;&#9;t.Fatalf(&quot;constructed span context is invalid&quot;)&#10;&#9;}&#10;&#10;&#9;// Detect unexpected forwards: se next.Handle viene chiamato quando non dovrebbe,&#10;&#9;// il WaitGroup si decrementarà e il test fallirà.&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;buffered&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;// aspetta che il buffer sia stato creato dal worker&#10;&#9;bufferCreated := false&#10;&#9;deadline := time.Now().Add(200 * time.Millisecond)&#10;&#9;for time.Now().Before(deadline) {&#10;&#9;&#9;h.mu.Lock()&#10;&#9;&#9;_, bufferCreated = h.buffers[tid.String()]&#10;&#9;&#9;h.mu.Unlock()&#10;&#9;&#9;if bufferCreated {&#10;&#9;&#9;&#9;break&#10;&#9;&#9;}&#10;&#9;&#9;time.Sleep(5 * time.Millisecond)&#10;&#9;}&#10;&#9;if !bufferCreated {&#10;&#9;&#9;t.Fatalf(&quot;buffer for trace %s was not created in time&quot;, tid.String())&#10;&#9;}&#10;&#10;&#9;// aspetta brevemente per verificare che NON sia stato forwarded&#10;&#9;select {&#10;&#9;case &lt;-func() chan struct{} {&#10;&#9;&#9;c := make(chan struct{})&#10;&#9;&#9;go func() {&#10;&#9;&#9;&#9;wg.Wait()&#10;&#9;&#9;&#9;close(c)&#10;&#9;&#9;}()&#10;&#9;&#9;return c&#10;&#9;}():&#10;&#9;&#9;// raccolgo dettagli sul record inoltrato&#10;&#9;&#9;next.mu.Lock()&#10;&#9;&#9;var msg string&#10;&#9;&#9;if len(next.records) &gt; 0 {&#10;&#9;&#9;&#9;msg = next.records[0].Message&#10;&#9;&#9;}&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forward to next.Handle immediately after Handle; forwarded message=%q&quot;, msg)&#10;&#9;case &lt;-time.After(100 * time.Millisecond):&#10;&#9;&#9;// ok, non è stato forwarded&#10;&#9;}&#10;&#10;&#9;// chiudo lo span con successo: non deve flushare i record&#10;&#9;h.EndSpanSuccess(ctx, tid.String())&#10;&#10;&#9;// attendiamo ancora un breve periodo per assicurarci che non arrivi nulla&#10;&#9;wg2 := &amp;sync.WaitGroup{}&#10;&#9;wg2.Add(1)&#10;&#9;next.wg = wg2&#10;&#9;select {&#10;&#9;case &lt;-func() chan struct{} {&#10;&#9;&#9;c := make(chan struct{})&#10;&#9;&#9;go func() {&#10;&#9;&#9;&#9;wg2.Wait()&#10;&#9;&#9;&#9;close(c)&#10;&#9;&#9;}()&#10;&#9;&#9;return c&#10;&#9;}():&#10;&#9;&#9;// raccolgo dettagli sul record inoltrato&#10;&#9;&#9;next.mu.Lock()&#10;&#9;&#9;var msg2 string&#10;&#9;&#9;if len(next.records) &gt; 0 {&#10;&#9;&#9;&#9;msg2 = next.records[0].Message&#10;&#9;&#9;}&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forward to next.Handle after EndSpanSuccess; forwarded message=%q&quot;, msg2)&#10;&#9;case &lt;-time.After(100 * time.Millisecond):&#10;&#9;&#9;// ok, non è stato forwarded&#10;&#9;}&#10;}&#10;&#10;// Test 3: immediate flush on error level&#10;func TestImmediateFlushOnError(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{2, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelError, &quot;errnow&quot;, 0)&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// Wait for flush&#10;&#9;c := make(chan struct{})&#10;&#9;go func() { wg.Wait(); close(c) }()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for immediate flush on error level&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test 4: timeout triggers flush&#10;func TestTimeoutTriggersFlush(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 50*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{3, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{3, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;to-be-timed-out&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// aspetta che il timer faccia il flush&#10;&#9;c := make(chan struct{})&#10;&#9;go func() { wg.Wait(); close(c) }()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for timeout-based flush&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test 5: drop when channel is full&#10;func TestDropWhenChannelFull(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// create handler with small buffer to provoke drops without reassigning channel&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 1, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;droptest&quot;, 0)&#10;&#9;// rapidly call Handle many times to trigger drops&#10;&#9;for i := 0; i &lt; 200; i++ {&#10;&#9;&#9;_ = h.Handle(context.Background(), r)&#10;&#9;}&#10;&#9;// slight wait to allow async counters to be updated&#10;&#9;time.Sleep(50 * time.Millisecond)&#10;&#10;&#9;// verifico che il contatore di drop sul fake meter sia stato incrementato&#10;&#9;calls := fm.counters[&quot;logging_dropped_operations&quot;]&#10;&#9;if calls == nil || len(*calls) == 0 {&#10;&#9;&#9;t.Fatalf(&quot;expected dropCounter.Add to be called at least once, got 0 calls&quot;)&#10;&#9;}&#10;}&#10;&#10;// --- TESTS PER CASI METER == nil ---&#10;&#10;// Test A: forwarding when no trace present and meter is nil&#10;func TestForwardingNoTrace_MeterNil(t *testing.T) {&#10;&#9;var fm MyMeter = nil&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;no-trace-nilmeter&quot;, 0)&#10;&#9;var ctx = context.Background()&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// aspetta che next riceva&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for next.Handle for no-trace record with nil meter&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test B: buffering + EndSpanSuccess with meter nil (should cleanup without flush)&#10;func TestBufferingEndSpanSuccess_MeterNil(t *testing.T) {&#10;&#9;var fm MyMeter = nil&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;// costruisco un ctx con SpanContext valido contenente un traceID&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{1, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// sanity check&#10;&#9;if !sc.IsValid() {&#10;&#9;&#9;t.Fatalf(&quot;constructed span context is invalid&quot;)&#10;&#9;}&#10;&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;buffered-nilmeter&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;// aspetta che il buffer sia stato creato dal worker&#10;&#9;bufferCreated := false&#10;&#9;deadline := time.Now().Add(200 * time.Millisecond)&#10;&#9;for time.Now().Before(deadline) {&#10;&#9;&#9;h.mu.Lock()&#10;&#9;&#9;_, bufferCreated = h.buffers[tid.String()]&#10;&#9;&#9;h.mu.Unlock()&#10;&#9;&#9;if bufferCreated {&#10;&#9;&#9;&#9;break&#10;&#9;&#9;}&#10;&#9;&#9;time.Sleep(5 * time.Millisecond)&#10;&#9;}&#10;&#9;if !bufferCreated {&#10;&#9;&#9;t.Fatalf(&quot;buffer for trace %s was not created in time (nil meter)&quot;, tid.String())&#10;&#9;}&#10;&#10;&#9;// aspetta brevemente per verificare che NON sia stato forwarded&#10;&#9;select {&#10;&#9;case &lt;-func() chan struct{} {&#10;&#9;&#9;c := make(chan struct{})&#10;&#9;&#9;go func() {&#10;&#9;&#9;&#9;wg.Wait()&#10;&#9;&#9;&#9;close(c)&#10;&#9;&#9;}()&#10;&#9;&#9;return c&#10;&#9;}():&#10;&#9;&#9;// raccolgo dettagli sul record inoltrato&#10;&#9;&#9;next.mu.Lock()&#10;&#9;&#9;var msg string&#10;&#9;&#9;if len(next.records) &gt; 0 {&#10;&#9;&#9;&#9;msg = next.records[0].Message&#10;&#9;&#9;}&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forward to next.Handle immediately after Handle; forwarded message=%q&quot;, msg)&#10;&#9;case &lt;-time.After(100 * time.Millisecond):&#10;&#9;&#9;// ok, non è stato forwarded&#10;&#9;}&#10;&#10;&#9;// chiudo lo span con successo: non deve flushare i record&#10;&#9;h.EndSpanSuccess(ctx, tid.String())&#10;&#10;&#9;// attendiamo ancora un breve periodo per assicurarci che non arrivi nulla&#10;&#9;wg2 := &amp;sync.WaitGroup{}&#10;&#9;wg2.Add(1)&#10;&#9;next.wg = wg2&#10;&#9;select {&#10;&#9;case &lt;-func() chan struct{} {&#10;&#9;&#9;c := make(chan struct{})&#10;&#9;&#9;go func() {&#10;&#9;&#9;&#9;wg2.Wait()&#10;&#9;&#9;&#9;close(c)&#10;&#9;&#9;}()&#10;&#9;&#9;return c&#10;&#9;}():&#10;&#9;&#9;// raccolgo dettagli sul record inoltrato&#10;&#9;&#9;next.mu.Lock()&#10;&#9;&#9;var msg2 string&#10;&#9;&#9;if len(next.records) &gt; 0 {&#10;&#9;&#9;&#9;msg2 = next.records[0].Message&#10;&#9;&#9;}&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forward to next.Handle after EndSpanSuccess (nil meter); forwarded message=%q&quot;, msg2)&#10;&#9;case &lt;-time.After(100 * time.Millisecond):&#10;&#9;&#9;// ok, non è stato forwarded&#10;&#9;}&#10;}&#10;&#10;// Test C: immediate flush on error level with meter nil&#10;func TestImmediateFlushOnError_MeterNil(t *testing.T) {&#10;&#9;var fm MyMeter = nil&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{2, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelError, &quot;errnow-nilmeter&quot;, 0)&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// Wait for flush&#10;&#9;c := make(chan struct{})&#10;&#9;go func() { wg.Wait(); close(c) }()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for immediate flush on error level with nil meter&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test D: drop when channel is full with meter nil (should not panic)&#10;func TestDropWhenChannelFull_MeterNil(t *testing.T) {&#10;&#9;var fm MyMeter = nil&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// create handler with small buffer to provoke drops without reassigning channel&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 1, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;droptest-nilmeter&quot;, 0)&#10;&#9;// rapidly call Handle many times to trigger drops&#10;&#9;for i := 0; i &lt; 200; i++ {&#10;&#9;&#9;_ = h.Handle(context.Background(), r)&#10;&#9;}&#10;&#9;// slight wait to allow async processing&#10;&#9;time.Sleep(50 * time.Millisecond)&#10;&#9;// if we reach here without panic the behavior is acceptable; assert no records nil&#10;&#9;// ensure next handler didn't receive a negative number of records (sanity)&#10;&#9;next.mu.Lock()&#10;&#9;cnt := len(next.records)&#10;&#9;next.mu.Unlock()&#10;&#9;if cnt &lt; 0 {&#10;&#9;&#9;t.Fatalf(&quot;invalid records count: %d&quot;, cnt)&#10;&#9;}&#10;}&#10;&#10;// Test: per-span custom timeout triggers flush at custom duration&#10;func TestPerSpanCustomTimeout(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// default lungo, user custom corto&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{9, 9, 9, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{9, 9, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// imposto timeout custom brevissimo&#10;&#9;custom := 50 * time.Millisecond&#10;&#9;h.StartSpan(ctx, tid.String(), &amp;custom)&#10;&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;per-span-custom&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok: flush avvenuto entro custom timeout&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for custom per-span timeout flush&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test: per-span nil disables timeout (no flush)&#10;func TestPerSpanDisableTimeout(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// default breve ma lo disabilitiamo per lo span&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 50*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{8, 8, 8, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{8, 8, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// disabilito il timeout per questo span&#10;&#9;h.StartSpan(ctx, tid.String(), nil)&#10;&#10;&#9;// preparo next per rilevare eventuale forward (non ci deve essere)&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;per-span-disabled&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;// aspettiamo un tempo maggiore del default: se riceviamo qualcosa è un errore&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;t.Fatal(&quot;unexpected flush: per-span timeout was disabled but flush occurred&quot;)&#10;&#9;case &lt;-time.After(200 * time.Millisecond):&#10;&#9;&#9;// ok: nessun flush automatico&#10;&#9;}&#10;&#10;&#9;// cleanup esplicito&#10;&#9;h.EndSpanSuccess(ctx, tid.String())&#10;}&#10;&#10;// Test: per-span pointer to 0 uses handler default timeout&#10;func TestPerSpanZeroUsesDefault(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// default medio&#10;&#9;defaultTimeout := 60 * time.Millisecond&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, defaultTimeout)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{7, 7, 7, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{7, 7, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;zero := time.Duration(0)&#10;&#9;h.StartSpan(ctx, tid.String(), &amp;zero) // dovrebbe usare defaultTimeout&#10;&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;per-span-zero&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for default timeout flush when per-span value == 0&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test: per-span minimum log level filtering&#10;func TestPerSpanMinLevelFiltering(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;// costruisco un ctx con SpanContext valido contenente un traceID&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{4, 4, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// Imposto il livello minimo a WARN per questo span&#10;&#9;min := slog.LevelWarn&#10;&#9;h.SetSpanMinLevel(tid.String(), &amp;min)&#10;&#10;&#9;// 1) Invio un record INFO: non dovrebbe essere inoltrato&#10;&#9;rInfo := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;info-should-be-dropped&quot;, 0)&#10;&#9;_ = h.Handle(ctx, rInfo)&#10;&#9;// attendiamo un po' per dare tempo al worker di processare&#10;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;next.mu.Lock()&#10;&#9;if len(next.records) != 0 {&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;expected 0 forwarded records for INFO below min level, got %d&quot;, len(next.records))&#10;&#9;}&#10;&#9;next.mu.Unlock()&#10;&#10;&#9;// 2) Invio un record WARN: dovrebbe essere inoltrato&#10;&#9;rWarn := slog.NewRecord(time.Now(), slog.LevelWarn, &quot;warn-should-pass&quot;, 0)&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, rWarn)&#10;&#9;c := make(chan struct{})&#10;&#9;go func() { wg.Wait(); close(c) }()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for WARN to be forwarded&quot;)&#10;&#9;}&#10;&#9;// verifico messaggio&#10;&#9;next.mu.Lock()&#10;&#9;if len(next.records) == 0 {&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatal(&quot;expected at least one forwarded record for WARN&quot;)&#10;&#9;}&#10;&#9;if next.records[len(next.records)-1].Message != &quot;warn-should-pass&quot; {&#10;&#9;&#9;msg := next.records[len(next.records)-1].Message&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forwarded message for WARN: %q&quot;, msg)&#10;&#9;}&#10;&#9;next.mu.Unlock()&#10;&#10;&#9;// 3) Rimuovo il filtro e invio INFO: ora dovrebbe essere inoltrato&#10;&#9;h.SetSpanMinLevel(tid.String(), nil)&#10;&#9;rInfo2 := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;info-should-pass-after-remove&quot;, 0)&#10;&#9;wg2 := &amp;sync.WaitGroup{}&#10;&#9;wg2.Add(1)&#10;&#9;next.wg = wg2&#10;&#9;_ = h.Handle(ctx, rInfo2)&#10;&#9;c2 := make(chan struct{})&#10;&#9;go func() { wg2.Wait(); close(c2) }()&#10;&#9;select {&#10;&#9;case &lt;-c2:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for INFO to be forwarded after removing min-level filter&quot;)&#10;&#9;}&#10;&#9;// verifico messaggio&#10;&#9;next.mu.Lock()&#10;&#9;if len(next.records) == 0 {&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatal(&quot;expected at least one forwarded record after removing filter&quot;)&#10;&#9;}&#10;&#9;if next.records[len(next.records)-1].Message != &quot;info-should-pass-after-remove&quot; {&#10;&#9;&#9;msg := next.records[len(next.records)-1].Message&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forwarded message after removing filter: %q&quot;, msg)&#10;&#9;}&#10;&#9;next.mu.Unlock()&#10;}&#10;" />
              <option name="updatedContent" value="package pkg&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;testing&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;log/slog&quot;&#10;&#10;&#9;&quot;go.opentelemetry.io/otel/metric&quot;&#10;&#9;&quot;go.opentelemetry.io/otel/trace&quot;&#10;)&#10;&#10;// fakeCounter registra le chiamate a Add per ispezione nei test&#10;type counterCall struct {&#10;&#9;ctx   context.Context&#10;&#9;value int64&#10;}&#10;&#10;type fakeCounter struct {&#10;&#9;name  string&#10;&#9;calls *[]counterCall&#10;}&#10;&#10;func (f *fakeCounter) Add(ctx context.Context, value int64, _ ...metric.AddOption) {&#10;&#9;*f.calls = append(*f.calls, counterCall{ctx: ctx, value: value})&#10;}&#10;&#10;// implementa le interfacce usate (Int64CounterLike e Int64UpDownCounterLike hanno lo stesso metodo Add)&#10;&#10;// fakeMeter crea strumenti fake che registrano le chiamate&#10;type fakeMeter struct {&#10;&#9;counters map[string]*[]counterCall&#10;}&#10;&#10;func newFakeMeter() *fakeMeter {&#10;&#9;return &amp;fakeMeter{counters: map[string]*[]counterCall{}}&#10;}&#10;&#10;func (m *fakeMeter) Int64Counter(name string, _ ...metric.InstrumentOption) (Int64CounterLike, error) {&#10;&#9;arr := make([]counterCall, 0)&#10;&#9;m.counters[name] = &amp;arr&#10;&#9;return &amp;fakeCounter{name: name, calls: m.counters[name]}, nil&#10;}&#10;&#10;func (m *fakeMeter) Int64UpDownCounter(name string, _ ...metric.InstrumentOption) (Int64UpDownCounterLike, error) {&#10;&#9;arr := make([]counterCall, 0)&#10;&#9;m.counters[name] = &amp;arr&#10;&#9;// riuso fakeCounter poiché Add ha la stessa forma&#10;&#9;return &amp;fakeCounter{name: name, calls: m.counters[name]}, nil&#10;}&#10;&#10;// fakeSlogHandler cattura i record inoltrati e permette di sincronizzare i test&#10;type fakeSlogHandler struct {&#10;&#9;mu      sync.Mutex&#10;&#9;records []slog.Record&#10;&#9;wg      *sync.WaitGroup&#10;}&#10;&#10;func newFakeSlogHandler() *fakeSlogHandler {&#10;&#9;return &amp;fakeSlogHandler{}&#10;}&#10;&#10;func (f *fakeSlogHandler) Handle(ctx context.Context, r slog.Record) error {&#10;&#9;f.mu.Lock()&#10;&#9;defer f.mu.Unlock()&#10;&#9;f.records = append(f.records, r)&#10;&#9;if f.wg != nil {&#10;&#9;&#9;f.wg.Done()&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func (f *fakeSlogHandler) Enabled(ctx context.Context, level slog.Level) bool { return true }&#10;func (f *fakeSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler           { return f }&#10;func (f *fakeSlogHandler) WithGroup(name string) slog.Handler                 { return f }&#10;&#10;// helper: aspetta fino a timeout che il fake handler abbia almeno n record&#10;func waitForRecords(t *testing.T, fh *fakeSlogHandler, n int, timeout time.Duration) {&#10;&#9;deadline := time.Now().Add(timeout)&#10;&#9;for time.Now().Before(deadline) {&#10;&#9;&#9;fh.mu.Lock()&#10;&#9;&#9;cnt := len(fh.records)&#10;&#9;&#9;fh.mu.Unlock()&#10;&#9;&#9;if cnt &gt;= n {&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;time.Sleep(5 * time.Millisecond)&#10;&#9;}&#10;&#9;t.Fatalf(&quot;timed out waiting for %d records, got %d&quot;, n, len(fh.records))&#10;}&#10;&#10;// Test 1: forwarding when no trace present&#10;func TestForwardingNoTrace(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;no-trace&quot;, 0)&#10;&#9;var ctx = context.Background()&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// aspetta che next riceva&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for next.Handle for no-trace record&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test 2: buffering + EndSpanSuccess (should cleanup without flush)&#10;func TestBufferingEndSpanSuccess(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;// costruisco un ctx con SpanContext valido contenente un traceID&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{1, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// sanity check sulla validità del contesto&#10;&#9;if !sc.IsValid() {&#10;&#9;&#9;t.Fatalf(&quot;constructed span context is invalid&quot;)&#10;&#9;}&#10;&#10;&#9;// Detect unexpected forwards: se next.Handle viene chiamato quando non dovrebbe,&#10;&#9;// il WaitGroup si decrementarà e il test fallirà.&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;buffered&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;// aspetta che il buffer sia stato creato dal worker&#10;&#9;bufferCreated := false&#10;&#9;deadline := time.Now().Add(200 * time.Millisecond)&#10;&#9;for time.Now().Before(deadline) {&#10;&#9;&#9;h.mu.Lock()&#10;&#9;&#9;_, bufferCreated = h.buffers[tid.String()]&#10;&#9;&#9;h.mu.Unlock()&#10;&#9;&#9;if bufferCreated {&#10;&#9;&#9;&#9;break&#10;&#9;&#9;}&#10;&#9;&#9;time.Sleep(5 * time.Millisecond)&#10;&#9;}&#10;&#9;if !bufferCreated {&#10;&#9;&#9;t.Fatalf(&quot;buffer for trace %s was not created in time&quot;, tid.String())&#10;&#9;}&#10;&#10;&#9;// aspetta brevemente per verificare che NON sia stato forwarded&#10;&#9;select {&#10;&#9;case &lt;-func() chan struct{} {&#10;&#9;&#9;c := make(chan struct{})&#10;&#9;&#9;go func() {&#10;&#9;&#9;&#9;wg.Wait()&#10;&#9;&#9;&#9;close(c)&#10;&#9;&#9;}()&#10;&#9;&#9;return c&#10;&#9;}():&#10;&#9;&#9;// raccolgo dettagli sul record inoltrato&#10;&#9;&#9;next.mu.Lock()&#10;&#9;&#9;var msg string&#10;&#9;&#9;if len(next.records) &gt; 0 {&#10;&#9;&#9;&#9;msg = next.records[0].Message&#10;&#9;&#9;}&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forward to next.Handle immediately after Handle; forwarded message=%q&quot;, msg)&#10;&#9;case &lt;-time.After(100 * time.Millisecond):&#10;&#9;&#9;// ok, non è stato forwarded&#10;&#9;}&#10;&#10;&#9;// chiudo lo span con successo: non deve flushare i record&#10;&#9;h.EndSpanSuccess(ctx, tid.String())&#10;&#10;&#9;// attendiamo ancora un breve periodo per assicurarci che non arrivi nulla&#10;&#9;wg2 := &amp;sync.WaitGroup{}&#10;&#9;wg2.Add(1)&#10;&#9;next.wg = wg2&#10;&#9;select {&#10;&#9;case &lt;-func() chan struct{} {&#10;&#9;&#9;c := make(chan struct{})&#10;&#9;&#9;go func() {&#10;&#9;&#9;&#9;wg2.Wait()&#10;&#9;&#9;&#9;close(c)&#10;&#9;&#9;}()&#10;&#9;&#9;return c&#10;&#9;}():&#10;&#9;&#9;// raccolgo dettagli sul record inoltrato&#10;&#9;&#9;next.mu.Lock()&#10;&#9;&#9;var msg2 string&#10;&#9;&#9;if len(next.records) &gt; 0 {&#10;&#9;&#9;&#9;msg2 = next.records[0].Message&#10;&#9;&#9;}&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forward to next.Handle after EndSpanSuccess; forwarded message=%q&quot;, msg2)&#10;&#9;case &lt;-time.After(100 * time.Millisecond):&#10;&#9;&#9;// ok, non è stato forwarded&#10;&#9;}&#10;}&#10;&#10;// Test 3: immediate flush on error level&#10;func TestImmediateFlushOnError(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{2, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelError, &quot;errnow&quot;, 0)&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// Wait for flush&#10;&#9;c := make(chan struct{})&#10;&#9;go func() { wg.Wait(); close(c) }()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for immediate flush on error level&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test 4: timeout triggers flush&#10;func TestTimeoutTriggersFlush(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 50*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{3, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{3, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;to-be-timed-out&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// aspetta che il timer faccia il flush&#10;&#9;c := make(chan struct{})&#10;&#9;go func() { wg.Wait(); close(c) }()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for timeout-based flush&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test 5: drop when channel is full&#10;func TestDropWhenChannelFull(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// create handler with small buffer to provoke drops without reassigning channel&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 1, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;droptest&quot;, 0)&#10;&#9;// rapidly call Handle many times to trigger drops&#10;&#9;for i := 0; i &lt; 200; i++ {&#10;&#9;&#9;_ = h.Handle(context.Background(), r)&#10;&#9;}&#10;&#9;// slight wait to allow async counters to be updated&#10;&#9;time.Sleep(50 * time.Millisecond)&#10;&#10;&#9;// verifico che il contatore di drop sul fake meter sia stato incrementato&#10;&#9;calls := fm.counters[&quot;logging_dropped_operations&quot;]&#10;&#9;if calls == nil || len(*calls) == 0 {&#10;&#9;&#9;t.Fatalf(&quot;expected dropCounter.Add to be called at least once, got 0 calls&quot;)&#10;&#9;}&#10;}&#10;&#10;// --- TESTS PER CASI METER == nil ---&#10;&#10;// Test A: forwarding when no trace present and meter is nil&#10;func TestForwardingNoTrace_MeterNil(t *testing.T) {&#10;&#9;var fm MyMeter = nil&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;no-trace-nilmeter&quot;, 0)&#10;&#9;var ctx = context.Background()&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// aspetta che next riceva&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for next.Handle for no-trace record with nil meter&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test B: buffering + EndSpanSuccess with meter nil (should cleanup without flush)&#10;func TestBufferingEndSpanSuccess_MeterNil(t *testing.T) {&#10;&#9;var fm MyMeter = nil&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;// costruisco un ctx con SpanContext valido contenente un traceID&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{1, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// sanity check&#10;&#9;if !sc.IsValid() {&#10;&#9;&#9;t.Fatalf(&quot;constructed span context is invalid&quot;)&#10;&#9;}&#10;&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;buffered-nilmeter&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;// aspetta che il buffer sia stato creato dal worker&#10;&#9;bufferCreated := false&#10;&#9;deadline := time.Now().Add(200 * time.Millisecond)&#10;&#9;for time.Now().Before(deadline) {&#10;&#9;&#9;h.mu.Lock()&#10;&#9;&#9;_, bufferCreated = h.buffers[tid.String()]&#10;&#9;&#9;h.mu.Unlock()&#10;&#9;&#9;if bufferCreated {&#10;&#9;&#9;&#9;break&#10;&#9;&#9;}&#10;&#9;&#9;time.Sleep(5 * time.Millisecond)&#10;&#9;}&#10;&#9;if !bufferCreated {&#10;&#9;&#9;t.Fatalf(&quot;buffer for trace %s was not created in time (nil meter)&quot;, tid.String())&#10;&#9;}&#10;&#10;&#9;// aspetta brevemente per verificare che NON sia stato forwarded&#10;&#9;select {&#10;&#9;case &lt;-func() chan struct{} {&#10;&#9;&#9;c := make(chan struct{})&#10;&#9;&#9;go func() {&#10;&#9;&#9;&#9;wg.Wait()&#10;&#9;&#9;&#9;close(c)&#10;&#9;&#9;}()&#10;&#9;&#9;return c&#10;&#9;}():&#10;&#9;&#9;// raccolgo dettagli sul record inoltrato&#10;&#9;&#9;next.mu.Lock()&#10;&#9;&#9;var msg string&#10;&#9;&#9;if len(next.records) &gt; 0 {&#10;&#9;&#9;&#9;msg = next.records[0].Message&#10;&#9;&#9;}&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forward to next.Handle immediately after Handle; forwarded message=%q&quot;, msg)&#10;&#9;case &lt;-time.After(100 * time.Millisecond):&#10;&#9;&#9;// ok, non è stato forwarded&#10;&#9;}&#10;&#10;&#9;// chiudo lo span con successo: non deve flushare i record&#10;&#9;h.EndSpanSuccess(ctx, tid.String())&#10;&#10;&#9;// attendiamo ancora un breve periodo per assicurarci che non arrivi nulla&#10;&#9;wg2 := &amp;sync.WaitGroup{}&#10;&#9;wg2.Add(1)&#10;&#9;next.wg = wg2&#10;&#9;select {&#10;&#9;case &lt;-func() chan struct{} {&#10;&#9;&#9;c := make(chan struct{})&#10;&#9;&#9;go func() {&#10;&#9;&#9;&#9;wg2.Wait()&#10;&#9;&#9;&#9;close(c)&#10;&#9;&#9;}()&#10;&#9;&#9;return c&#10;&#9;}():&#10;&#9;&#9;// raccolgo dettagli sul record inoltrato&#10;&#9;&#9;next.mu.Lock()&#10;&#9;&#9;var msg2 string&#10;&#9;&#9;if len(next.records) &gt; 0 {&#10;&#9;&#9;&#9;msg2 = next.records[0].Message&#10;&#9;&#9;}&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forward to next.Handle after EndSpanSuccess (nil meter); forwarded message=%q&quot;, msg2)&#10;&#9;case &lt;-time.After(100 * time.Millisecond):&#10;&#9;&#9;// ok, non è stato forwarded&#10;&#9;}&#10;}&#10;&#10;// Test C: immediate flush on error level with meter nil&#10;func TestImmediateFlushOnError_MeterNil(t *testing.T) {&#10;&#9;var fm MyMeter = nil&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{2, 2, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelError, &quot;errnow-nilmeter&quot;, 0)&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, r)&#10;&#9;// Wait for flush&#10;&#9;c := make(chan struct{})&#10;&#9;go func() { wg.Wait(); close(c) }()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for immediate flush on error level with nil meter&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test D: drop when channel is full with meter nil (should not panic)&#10;func TestDropWhenChannelFull_MeterNil(t *testing.T) {&#10;&#9;var fm MyMeter = nil&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// create handler with small buffer to provoke drops without reassigning channel&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 1, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;droptest-nilmeter&quot;, 0)&#10;&#9;// rapidly call Handle many times to trigger drops&#10;&#9;for i := 0; i &lt; 200; i++ {&#10;&#9;&#9;_ = h.Handle(context.Background(), r)&#10;&#9;}&#10;&#9;// slight wait to allow async processing&#10;&#9;time.Sleep(50 * time.Millisecond)&#10;&#9;// if we reach here without panic the behavior is acceptable; assert no records nil&#10;&#9;// ensure next handler didn't receive a negative number of records (sanity)&#10;&#9;next.mu.Lock()&#10;&#9;cnt := len(next.records)&#10;&#9;next.mu.Unlock()&#10;&#9;if cnt &lt; 0 {&#10;&#9;&#9;t.Fatalf(&quot;invalid records count: %d&quot;, cnt)&#10;&#9;}&#10;}&#10;&#10;// Test: per-span custom timeout triggers flush at custom duration&#10;func TestPerSpanCustomTimeout(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// default lungo, user custom corto&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{9, 9, 9, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{9, 9, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// imposto timeout custom brevissimo&#10;&#9;custom := 50 * time.Millisecond&#10;&#9;h.StartSpan(ctx, tid.String(), &amp;custom)&#10;&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;per-span-custom&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok: flush avvenuto entro custom timeout&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for custom per-span timeout flush&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test: per-span nil disables timeout (no flush)&#10;func TestPerSpanDisableTimeout(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// default breve ma lo disabilitiamo per lo span&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 50*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{8, 8, 8, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{8, 8, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// disabilito il timeout per questo span&#10;&#9;h.StartSpan(ctx, tid.String(), nil)&#10;&#10;&#9;// preparo next per rilevare eventuale forward (non ci deve essere)&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;per-span-disabled&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;// aspettiamo un tempo maggiore del default: se riceviamo qualcosa è un errore&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;t.Fatal(&quot;unexpected flush: per-span timeout was disabled but flush occurred&quot;)&#10;&#9;case &lt;-time.After(200 * time.Millisecond):&#10;&#9;&#9;// ok: nessun flush automatico&#10;&#9;}&#10;&#10;&#9;// cleanup esplicito&#10;&#9;h.EndSpanSuccess(ctx, tid.String())&#10;}&#10;&#10;// Test: per-span pointer to 0 uses handler default timeout&#10;func TestPerSpanZeroUsesDefault(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;// default medio&#10;&#9;defaultTimeout := 60 * time.Millisecond&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, defaultTimeout)&#10;&#9;defer h.Close()&#10;&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{7, 7, 7, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{7, 7, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;zero := time.Duration(0)&#10;&#9;h.StartSpan(ctx, tid.String(), &amp;zero) // dovrebbe usare defaultTimeout&#10;&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#10;&#9;r := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;per-span-zero&quot;, 0)&#10;&#9;_ = h.Handle(ctx, r)&#10;&#10;&#9;c := make(chan struct{})&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(c)&#10;&#9;}()&#10;&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for default timeout flush when per-span value == 0&quot;)&#10;&#9;}&#10;}&#10;&#10;// Test: per-span minimum log level filtering&#10;func TestPerSpanMinLevelFiltering(t *testing.T) {&#10;&#9;fm := newFakeMeter()&#10;&#9;next := newFakeSlogHandler()&#10;&#9;h := NewAsyncBufferedHandler(next, fm, 10, 200*time.Millisecond)&#10;&#9;defer h.Close()&#10;&#10;&#9;// costruisco un ctx con SpanContext valido contenente un traceID&#10;&#9;var tid trace.TraceID&#10;&#9;copy(tid[:], []byte{4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16})&#10;&#9;var sid trace.SpanID&#10;&#9;copy(sid[:], []byte{4, 4, 3, 4, 5, 6, 7, 8})&#10;&#9;sc := trace.NewSpanContext(trace.SpanContextConfig{TraceID: tid, SpanID: sid, TraceFlags: trace.FlagsSampled})&#10;&#9;ctx := trace.ContextWithSpanContext(context.Background(), sc)&#10;&#10;&#9;// Imposto il livello minimo a WARN per questo span&#10;&#9;minLevel := slog.LevelWarn&#10;&#9;h.SetSpanMinLevel(tid.String(), &amp;minLevel)&#10;&#10;&#9;// 1) Invio un record INFO: non dovrebbe essere inoltrato&#10;&#9;rInfo := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;info-should-be-dropped&quot;, 0)&#10;&#9;_ = h.Handle(ctx, rInfo)&#10;&#9;// attendiamo un po' per dare tempo al worker di processare&#10;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;next.mu.Lock()&#10;&#9;if len(next.records) != 0 {&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;expected 0 forwarded records for INFO below min level, got %d&quot;, len(next.records))&#10;&#9;}&#10;&#9;next.mu.Unlock()&#10;&#10;&#9;// 2) Invio un record WARN: dovrebbe essere inoltrato&#10;&#9;rWarn := slog.NewRecord(time.Now(), slog.LevelWarn, &quot;warn-should-pass&quot;, 0)&#10;&#9;wg := &amp;sync.WaitGroup{}&#10;&#9;wg.Add(1)&#10;&#9;next.wg = wg&#10;&#9;_ = h.Handle(ctx, rWarn)&#10;&#9;c := make(chan struct{})&#10;&#9;go func() { wg.Wait(); close(c) }()&#10;&#9;select {&#10;&#9;case &lt;-c:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for WARN to be forwarded&quot;)&#10;&#9;}&#10;&#9;// verifico messaggio&#10;&#9;next.mu.Lock()&#10;&#9;if len(next.records) == 0 {&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatal(&quot;expected at least one forwarded record for WARN&quot;)&#10;&#9;}&#10;&#9;if next.records[len(next.records)-1].Message != &quot;warn-should-pass&quot; {&#10;&#9;&#9;msg := next.records[len(next.records)-1].Message&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forwarded message for WARN: %q&quot;, msg)&#10;&#9;}&#10;&#9;next.mu.Unlock()&#10;&#10;&#9;// 3) Rimuovo il filtro e invio INFO: ora dovrebbe essere inoltrato&#10;&#9;h.SetSpanMinLevel(tid.String(), nil)&#10;&#9;rInfo2 := slog.NewRecord(time.Now(), slog.LevelInfo, &quot;info-should-pass-after-remove&quot;, 0)&#10;&#9;wg2 := &amp;sync.WaitGroup{}&#10;&#9;wg2.Add(1)&#10;&#9;next.wg = wg2&#10;&#9;_ = h.Handle(ctx, rInfo2)&#10;&#9;c2 := make(chan struct{})&#10;&#9;go func() { wg2.Wait(); close(c2) }()&#10;&#9;select {&#10;&#9;case &lt;-c2:&#10;&#9;&#9;// ok&#10;&#9;case &lt;-time.After(500 * time.Millisecond):&#10;&#9;&#9;t.Fatal(&quot;timeout waiting for INFO to be forwarded after removing min-level filter&quot;)&#10;&#9;}&#10;&#9;// verifico messaggio&#10;&#9;next.mu.Lock()&#10;&#9;if len(next.records) == 0 {&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatal(&quot;expected at least one forwarded record after removing filter&quot;)&#10;&#9;}&#10;&#9;if next.records[len(next.records)-1].Message != &quot;info-should-pass-after-remove&quot; {&#10;&#9;&#9;msg := next.records[len(next.records)-1].Message&#10;&#9;&#9;next.mu.Unlock()&#10;&#9;&#9;t.Fatalf(&quot;unexpected forwarded message after removing filter: %q&quot;, msg)&#10;&#9;}&#10;&#9;next.mu.Unlock()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>